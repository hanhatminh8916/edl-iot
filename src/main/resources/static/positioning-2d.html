<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>S∆° ƒê·ªì 2D Positioning - EDL SafeWork</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#1e40af">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="description" content="S∆° ƒë·ªì ƒë·ªãnh v·ªã 2D UWB theo th·ªùi gian th·ª±c">
    
    <!-- PWA Manifest & Icons -->
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" type="image/svg+xml" href="/images/icon.svg">
    <link rel="apple-touch-icon" href="/images/icon-192.png">
    
    <!-- Stylesheets -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="css/style.css?v=191">
    <link rel="stylesheet" href="css/location.css?v=191">
    <link rel="stylesheet" href="css/mobile-responsive.css">
    <style>
        .main-content {
            padding: 20px;
        }

        .canvas-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .canvas-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .canvas-header h2 {
            margin: 0;
            color: #333;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .control-group label {
            font-size: 14px;
            color: #666;
        }

        .control-group input[type="range"] {
            width: 150px;
        }

        .control-group span {
            min-width: 40px;
            font-weight: bold;
            color: #333;
        }

        #canvas2d {
            border: 2px solid #e0e0e0;
            border-radius: 4px;
            background: #f5f5f5;
            cursor: crosshair;
            display: block;
            margin: 0 auto;
        }

        .legend {
            display: flex;
            gap: 30px;
            margin-top: 15px;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 4px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
        }

        .legend-color.anchor {
            background: #2196F3;
        }

        .legend-color.tag {
            background: #f44336;
        }
        
        .legend-color.tag-offline {
            background: #9E9E9E;
        }

        /* ===== HIDE DEMO TAGS - NOW USING REALTIME UWB ===== */
        .demo-tag {
            display: none !important; /* ‚úÖ ·∫®n demo tags */
        }

        /* Distance lines for demo tags */
        .distance-line {
            position: absolute;
            background: rgba(76, 175, 80, 0.3);
            height: 2px;
            transform-origin: left center;
            z-index: 5;
            pointer-events: none;
        }

        .distance-label {
            position: absolute;
            background: white;
            border: 1px solid #4CAF50;
            padding: 2px 6px;
            font-size: 11px;
            font-weight: bold;
            color: #333;
            border-radius: 3px;
            z-index: 6;
            pointer-events: none;
            white-space: nowrap;
        }

        .info-panel {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .info-section {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
        }

        .info-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 16px;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 8px;
        }

        .device-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .device-item {
            padding: 8px;
            margin-bottom: 5px;
            background: white;
            border-radius: 4px;
            border-left: 3px solid #2196F3;
            font-size: 14px;
        }

        .device-item.tag {
            border-left-color: #f44336;
        }

        .device-item strong {
            color: #333;
        }

        .distance-info {
            font-size: 12px;
            color: #666;
            margin-top: 3px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
        }

        .btn-secondary {
            background: #2196F3;
            color: white;
        }

        .btn-secondary:hover {
            background: #0b7dda;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .status-indicator.online {
            background: #4CAF50;
        }

        .status-indicator.offline {
            background: #f44336;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-left">
            <div class="logo">
                <i class="fas fa-hard-hat"></i>
                <span>EDL SafeWork</span>
            </div>
        </div>
        <div class="header-right">
            <div class="user-profile">
                <i class="fas fa-user-circle"></i>
                <span id="usernameDisplay">vku123</span>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <nav class="nav-menu">
                <a href="index.html" class="nav-item">
                    <i class="fas fa-chart-line"></i>
                    <span>T·ªïng quan</span>
                </a>
                <a href="location.html" class="nav-item">
                    <i class="fas fa-map-marker-alt"></i>
                    <span>Gi√°m s√°t v·ªã tr√≠</span>
                </a>
                <a href="positioning-2d.html" class="nav-item active">
                    <i class="fas fa-ruler-combined"></i>
                    <span>S∆° ƒê·ªì 2D</span>
                </a>
                <a href="employees.html" class="nav-item">
                    <i class="fas fa-users"></i>
                    <span>Qu·∫£n l√Ω c√¥ng nh√¢n</span>
                </a>
                <a href="location.html" class="nav-item">
                    <i class="fas fa-exclamation-triangle"></i>
                    <span>C·∫£nh b√°o</span>
                </a>
                <a href="reports.html" class="nav-item">
                    <i class="fas fa-chart-bar"></i>
                    <span>B√°o c√°o</span>
                </a>
                <a href="#" class="nav-item">
                    <i class="fas fa-cog"></i>
                    <span>C√†i ƒë·∫∑t</span>
                </a>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Page Header -->
            <div class="page-header">
                <div>
                    <h1>üìê S∆° ƒê·ªì 2D Positioning System</h1>
                    <p id="viewMode" style="font-size: 16px; color: #666; margin-top: 8px;">
                        <i class="fas fa-globe"></i> Ch·∫ø ƒë·ªô: T·ªïng quan to√†n b·ªô khu v·ª±c
                    </p>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button class="btn btn-secondary" onclick="window.location.href='positioning-2d.html'" id="btnOverview" style="display:none;">
                        <i class="fas fa-th"></i> Xem t·ªïng quan
                    </button>
                    <button class="btn btn-primary" onclick="switchToZone()" id="btnBackToZone" style="display:none;">
                        <i class="fas fa-map-marked-alt"></i> Quay l·∫°i <span id="zoneName"></span>
                    </button>
                </div>
            </div>

        <!-- Canvas Container -->
        <div class="canvas-container">
            <div class="canvas-header">
                <h2 id="areaTitle">Khu V·ª±c Gi√°m S√°t (20m √ó 20m)</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>T·ª∑ l·ªá:</label>
                        <input type="range" id="scaleSlider" min="10" max="40" value="20" step="1">
                        <span id="scaleValue">20</span> px/m
                    </div>
                    <button class="btn btn-secondary" onclick="resetView()">Reset View</button>
                    <button class="btn btn-primary" onclick="toggleAnimation()">
                        <span id="animationBtn">‚è∏ D·ª´ng</span>
                    </button>
                </div>
            </div>
            
            <!-- Canvas wrapper with demo tags -->
            <div id="canvasWrapper" style="position: relative; display: inline-block;">
                <canvas id="canvas2d" width="800" height="800"></canvas>
                
                <!-- Demo animated tags -->
                <div class="demo-tag demo-tag-1" data-label="TAG1"></div>
            </div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color anchor"></div>
                    <span><strong>Anchor</strong> - Thi·∫øt b·ªã ƒë·ªãnh v·ªã c·ªë ƒë·ªãnh (UWB)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color tag"></div>
                    <span><strong>Tag Online</strong> - ƒêang ho·∫°t ƒë·ªông</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color tag-offline"></div>
                    <span><strong>Tag Offline</strong> - M·∫•t k·∫øt n·ªëi (v·ªã tr√≠ cu·ªëi)</span>
                </div>
                <div class="legend-item">
                    <span>üìè ƒê∆∞·ªùng cam: Kho·∫£ng c√°ch UWB realtime (meter)</span>
                </div>
            </div>
        </div>

        <!-- Info Panel -->
        <div class="info-panel">
            <h2>Th√¥ng Tin Chi Ti·∫øt</h2>
            <div class="info-grid">
                <div class="info-section">
                    <h3>üìç Danh S√°ch Anchor</h3>
                    <ul class="device-list" id="anchorList"></ul>
                </div>
                <div class="info-section">
                    <h3>üè∑Ô∏è Danh S√°ch Tag</h3>
                    <ul class="device-list" id="tagList"></ul>
                </div>
                <div class="info-section">
                    <h3>üìä Th·ªëng K√™</h3>
                    <div style="padding: 10px;">
                        <p><strong>T·ªïng Anchor:</strong> <span id="totalAnchors">0</span></p>
                        <p><strong>T·ªïng Tag:</strong> <span id="totalTags">0</span></p>
                        <p><strong>Tag Ho·∫°t ƒê·ªông:</strong> <span id="activeTags">0</span></p>
                        <p><strong>Kho·∫£ng C√°ch Trung B√¨nh:</strong> <span id="avgDistance">0</span> m</p>
                    </div>
                </div>
            </div>
        </div>
        </main>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
    <script src="js/global-alerts.js"></script>
    <script src="js/auth.js"></script>
    <script>
        const canvas = document.getElementById('canvas2d');
        const ctx = canvas.getContext('2d');
        
        // Configuration
        let scale = 20; // pixels per meter
        const areaSize = 20; // 20m √ó 20m
        let isAnimating = false; // ‚úÖ T·∫Øt animation demo, ch·ªâ d√πng UWB realtime

        // Zone filtering
        let currentZoneId = null;
        let currentZone = null;
        let previousZoneId = null; // Store previous zone for navigation

        // Check if zone parameter exists in URL
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('zone')) {
            currentZoneId = urlParams.get('zone');
            previousZoneId = currentZoneId; // Remember this zone
            loadZoneInfo(currentZoneId);
        }

        // Anchors - will be loaded from database
        let anchors = [];
        
        // Reference point for coordinate conversion (use first anchor as reference or fixed point)
        let referencePoint = null;
        
        // Switch back to overview mode
        function switchToOverview() {
            currentZoneId = null; // Clear current zone but keep previousZoneId
            loadAnchorsFromDatabase(); // Reload all anchors
            
            // Update UI
            document.getElementById('viewMode').innerHTML = `
                <i class="fas fa-globe"></i> Ch·∫ø ƒë·ªô: T·ªïng quan to√†n b·ªô khu v·ª±c
            `;
            document.getElementById('areaTitle').textContent = 'Khu V·ª±c Gi√°m S√°t (20m √ó 20m)';
            document.getElementById('btnOverview').style.display = 'none';
            
            // Show back to zone button if there was a previous zone
            if (previousZoneId && currentZone) {
                document.getElementById('btnBackToZone').style.display = 'inline-block';
                document.getElementById('zoneName').textContent = currentZone.name;
            }
            
            // Update URL without zone parameter
            window.history.pushState({}, '', 'positioning-2d.html');
        }
        
        // Switch back to previous zone
        function switchToZone() {
            if (previousZoneId) {
                window.location.href = `positioning-2d.html?zone=${previousZoneId}`;
            }
        }
        
        // Load zone information
        async function loadZoneInfo(zoneId) {
            try {
                const response = await fetch(`/api/zones/${zoneId}`);
                if (response.ok) {
                    currentZone = await response.json();
                    previousZoneId = zoneId; // Remember this zone
                    
                    document.getElementById('viewMode').innerHTML = `
                        <i class="fas fa-map-marked-alt"></i> Ch·∫ø ƒë·ªô: Khu v·ª±c chi ti·∫øt "<strong>${currentZone.name}</strong>"
                    `;
                    document.getElementById('areaTitle').textContent = `${currentZone.name} (Khu v·ª±c chi ti·∫øt)`;
                    document.getElementById('btnOverview').style.display = 'inline-block';
                    document.getElementById('btnBackToZone').style.display = 'none'; // Hide when in zone view
                    console.log('‚úÖ Viewing zone:', currentZone);
                }
            } catch (error) {
                console.error('Error loading zone info:', error);
            }
        }
        
        // Convert lat/lng to local x/y coordinates (meters)
        function latLngToXY(lat, lng, refLat, refLng) {
            // 1 degree latitude ‚âà 111,000 meters
            // 1 degree longitude ‚âà 111,000 * cos(latitude) meters
            const latDiff = (lat - refLat) * 111000;
            const lngDiff = (lng - refLng) * 111000 * Math.cos(refLat * Math.PI / 180);
            
            // Map to grid: bottom-left anchor as origin (0,0), scale to fit 20m area
            // x: longitude difference (east-west)
            // y: latitude difference (north-south)
            return { x: lngDiff, y: latDiff };
        }
        
        // Load anchors from database
        function loadAnchorsFromDatabase() {
            fetch('/api/anchors')
                .then(response => response.json())
                .then(data => {
                    console.log('‚úÖ Loaded anchors from DB:', data);
                    
                    // üÜï CLEAR ALL CACHES when loading new anchors
                    // This prevents position glitches when switching between zone/overview
                    lastPositions = {};
                    helmetPositions = {};
                    tags = [];
                    console.log('üßπ Cleared position caches');
                    
                    if (data.length === 0) {
                        console.warn('‚ö†Ô∏è No anchors in database');
                        anchors = [];
                        draw();
                        return;
                    }
                    
                    // ‚úÖ Filter anchors by zone if in detail mode
                    let filteredData = data;
                    if (currentZoneId) {
                        filteredData = data.filter(anchor => anchor.zoneId == currentZoneId);
                        console.log(`üîç Filtered to ${filteredData.length} anchors for zone ${currentZoneId}`);
                        
                        if (filteredData.length === 0) {
                            console.warn('‚ö†Ô∏è No anchors in this zone');
                            anchors = [];
                            draw();
                            return;
                        }
                    }
                    
                    // Use first anchor as reference point (origin)
                    referencePoint = {
                        lat: filteredData[0].latitude,
                        lng: filteredData[0].longitude
                    };
                    
                    // Convert all anchors to relative coordinates
                    const converted = filteredData.map(anchor => {
                        const pos = latLngToXY(anchor.latitude, anchor.longitude, referencePoint.lat, referencePoint.lng);
                        return {
                            id: anchor.anchorId,
                            name: anchor.name,
                            rawX: pos.x,
                            rawY: pos.y,
                            lat: anchor.latitude,
                            lng: anchor.longitude,
                            zoneId: anchor.zoneId,
                            status: 'online'
                        };
                    });
                    
                    // Find bounds
                    const xCoords = converted.map(a => a.rawX);
                    const yCoords = converted.map(a => a.rawY);
                    const minX = Math.min(...xCoords);
                    const maxX = Math.max(...xCoords);
                    const minY = Math.min(...yCoords);
                    const maxY = Math.max(...yCoords);
                    
                    const rangeX = maxX - minX || 1;
                    const rangeY = maxY - minY || 1;
                    const maxRange = Math.max(rangeX, rangeY);
                    
                    // Scale to fit in 18m x 18m (leave 1m margin on each side)
                    const scaleFactor = maxRange > 0 ? 18 / maxRange : 1;
                    
                    anchors = converted.map(anchor => ({
                        id: anchor.id,
                        name: anchor.name,
                        x: 1 + (anchor.rawX - minX) * scaleFactor,  // 1m margin
                        y: 1 + (anchor.rawY - minY) * scaleFactor,  // 1m margin
                        zoneId: anchor.zoneId,
                        status: anchor.status
                    }));
                    
                    console.log('‚úÖ Converted anchors to 2D:', anchors);
                    console.log('üìä Bounds:', { minX, maxX, minY, maxY, scaleFactor });
                    draw(); // Redraw canvas with new anchors
                })
                .catch(error => {
                    console.error('‚ùå Error loading anchors:', error);
                    anchors = [];
                    draw();
                });
        }

        // Safe zones data
        let safeZones = [];
        
        // Load safe zones from API
        function loadSafeZones() {
            fetch('/api/safe-zones')
                .then(response => response.json())
                .then(zones => {
                    safeZones = zones.filter(z => z.active).map(zone => ({
                        id: zone.id,
                        name: zone.zoneName,
                        coordinates: zone.polygonCoordinates,
                        color: zone.color || '#4CAF50'
                    }));
                    console.log('‚úÖ Loaded', safeZones.length, 'safe zones');
                    draw();
                })
                .catch(error => {
                    console.error('‚ùå Error loading safe zones:', error);
                    safeZones = [];
                });
        }
        
        // Check if point is inside polygon (Ray casting algorithm)
        function isPointInPolygon(x, y, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                
                const intersect = ((yi > y) !== (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }
        
        // Check if worker is in any safe zone
        function isWorkerInSafeZone(tag) {
            // DEFAULT: ALL workers are INSIDE safe zone (GREEN)
            // Only show RED if explicitly outside
            
            // Simple approach: If worker is very close to canvas edges, show RED
            const margin = 1; // 1 meter margin from edge
            if (tag.x < margin || tag.x > (areaSize - margin) || 
                tag.y < margin || tag.y > (areaSize - margin)) {
                return false; // Near boundary = outside
            }
            
            // Otherwise, always GREEN (inside safe zone)
            return true;
        }

        // Sample data - Tags (moving positions)
        let tags = []; // ‚úÖ B·ªè d·ªØ li·ªáu demo, ch·ªâ d√πng d·ªØ li·ªáu th·ª±c t·ª´ UWB
        
        // üìä Track last data timestamp for each tag (for offline detection)
        const tagLastDataTime = {};
        const OFFLINE_TIMEOUT_MS = 60000; // 60 seconds - longer timeout to prevent flicker

        // Calculate distance between two points
        function calculateDistance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        // Find nearest anchor for each tag
        function findNearestAnchor(tag) {
            let minDistance = Infinity;
            let nearestAnchor = null;

            anchors.forEach(anchor => {
                const dist = calculateDistance(tag.x, tag.y, anchor.x, anchor.y);
                if (dist < minDistance) {
                    minDistance = dist;
                    nearestAnchor = anchor;
                }
            });

            return { anchor: nearestAnchor, distance: minDistance };
        }

        // Draw grid
        function drawGrid() {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            // Vertical lines
            for (let i = 0; i <= areaSize; i++) {
                ctx.beginPath();
                ctx.moveTo(i * scale, 0);
                ctx.lineTo(i * scale, areaSize * scale);
                ctx.stroke();
            }

            // Horizontal lines
            for (let i = 0; i <= areaSize; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * scale);
                ctx.lineTo(areaSize * scale, i * scale);
                ctx.stroke();
            }

            // Draw labels
            ctx.fillStyle = '#999';
            ctx.font = '10px Arial';
            for (let i = 0; i <= areaSize; i += 5) {
                ctx.fillText(i + 'm', i * scale - 8, areaSize * scale + 15);
                ctx.fillText(i + 'm', -20, areaSize * scale - i * scale + 5);
            }
        }

        // Draw anchor
        function drawAnchor(anchor) {
            const x = anchor.x * scale;
            const y = (areaSize - anchor.y) * scale;

            // Draw circle
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, 2 * Math.PI);
            ctx.fillStyle = anchor.status === 'online' ? '#2196F3' : '#999';
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw label
            ctx.fillStyle = '#333';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(anchor.id, x, y - 15);
        }

        // Draw tag v·ªõi m√†u theo status (online=xanh, offline=x√°m)
        function drawTag(tag) {
            const x = tag.x * scale;
            const y = (areaSize - tag.y) * scale;
            
            // üé® M√†u s·∫Øc theo status
            let markerColor;
            if (tag.status === 'offline') {
                markerColor = '#9E9E9E'; // ‚ö™ X√ÅM khi offline
            } else if (tag.status === 'warning') {
                markerColor = '#FF9800'; // üü† CAM khi c·∫£nh b√°o
            } else {
                markerColor = '#f44336'; // üî¥ ƒê·ªé khi online (d·ªÖ nh√¨n h∆°n xanh)
            }

            // Draw circle with glow effect for online tags
            if (tag.status === 'online') {
                ctx.beginPath();
                ctx.arc(x, y, 14, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(244, 67, 54, 0.3)';
                ctx.fill();
            }
            
            // Draw main circle
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, 2 * Math.PI);
            ctx.fillStyle = markerColor;
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw label with name
            ctx.fillStyle = '#333';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(tag.id, x, y + 25);
            
            // Draw battery indicator if available
            if (tag.battery !== undefined) {
                const batteryText = `${Math.round(tag.battery)}%`;
                ctx.font = '10px Arial';
                ctx.fillStyle = tag.battery < 20 ? '#f44336' : '#666';
                ctx.fillText(batteryText, x, y + 38);
            }
        }

        // Draw distance lines from tag to ALL anchors with UWB data
        function drawTagDistanceLines(tag) {
            if (!tag.uwb) return;
            
            const x1 = tag.x * scale;
            const y1 = (areaSize - tag.y) * scale;
            
            // Draw line to each anchor
            anchors.forEach(anchor => {
                const anchorKey = anchor.id; // A0, A1, A2
                const distance = tag.uwb[anchorKey];
                
                if (distance && distance > 0) {
                    const x2 = anchor.x * scale;
                    const y2 = (areaSize - anchor.y) * scale;
                    
                    // Draw dashed line
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.strokeStyle = 'rgba(255, 152, 0, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Draw distance label at midpoint
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(midX - 18, midY - 8, 36, 16);
                    ctx.strokeStyle = '#FF9800';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(midX - 18, midY - 8, 36, 16);
                    
                    ctx.fillStyle = '#333';
                    ctx.font = 'bold 9px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(distance.toFixed(2) + 'm', midX, midY + 3);
                }
            });
        }

        // Draw distance line (legacy - for nearest anchor only)
        function drawDistanceLine(tag, anchor, distance) {
            const x1 = tag.x * scale;
            const y1 = (areaSize - tag.y) * scale;
            const x2 = anchor.x * scale;
            const y2 = (areaSize - anchor.y) * scale;

            // Draw line
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = 'rgba(76, 175, 80, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw distance label
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            ctx.fillStyle = '#fff';
            ctx.fillRect(midX - 25, midY - 10, 50, 20);
            ctx.strokeStyle = '#4CAF50';
            ctx.strokeRect(midX - 25, midY - 10, 50, 20);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(distance.toFixed(2) + 'm', midX, midY + 4);
        }

        // Update tag positions (simulate movement)
        function updateTagPositions() {
            if (!isAnimating) return;

            tags.forEach(tag => {
                // Update position
                tag.x += tag.vx;
                tag.y += tag.vy;

                // Bounce off walls
                if (tag.x <= 1 || tag.x >= areaSize - 1) {
                    tag.vx *= -1;
                }
                if (tag.y <= 1 || tag.y >= areaSize - 1) {
                    tag.vy *= -1;
                }

                // Keep within bounds
                tag.x = Math.max(1, Math.min(areaSize - 1, tag.x));
                tag.y = Math.max(1, Math.min(areaSize - 1, tag.y));
            });
        }

        // Draw safe zone polygon
        function drawSafeZone(zone) {
            if (!zone.coordinates || zone.coordinates.length < 3) return;
            
            ctx.beginPath();
            zone.coordinates.forEach((coord, index) => {
                // Convert to canvas coordinates - simplified for now
                // TODO: Implement proper lat/lng to canvas conversion
                const x = coord.lng * scale; // Simplified
                const y = (areaSize - coord.lat) * scale; // Simplified
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.closePath();
            
            // Fill with semi-transparent green
            ctx.fillStyle = 'rgba(76, 175, 80, 0.15)';
            ctx.fill();
            
            // Stroke with green border
            ctx.strokeStyle = zone.color || '#4CAF50';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw zone name
            if (zone.coordinates.length > 0) {
                const centerX = zone.coordinates.reduce((sum, c) => sum + c.lng, 0) / zone.coordinates.length * scale;
                const centerY = (areaSize - zone.coordinates.reduce((sum, c) => sum + c.lat, 0) / zone.coordinates.length) * scale;
                
                ctx.fillStyle = '#2E7D32';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(zone.name, centerX, centerY);
            }
        }

        // Main draw function
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Save context
            ctx.save();
            
            // Add padding
            ctx.translate(40, 40);

            // Draw grid
            drawGrid();
            
            // Draw safe zones FIRST (as background)
            safeZones.forEach(zone => drawSafeZone(zone));

            // üéØ Draw UWB distance lines from tags to anchors (with real distances)
            tags.forEach(tag => {
                if (tag.uwb && tag.status === 'online') {
                    drawTagDistanceLines(tag);
                } else {
                    // Fallback: Draw line to nearest anchor only
                    const { anchor, distance } = findNearestAnchor(tag);
                    if (anchor) {
                        drawDistanceLine(tag, anchor, distance);
                    }
                }
            });

            // Draw anchors
            anchors.forEach(anchor => drawAnchor(anchor));

            // Draw tags
            tags.forEach(tag => drawTag(tag));

            // Restore context
            ctx.restore();

            // Update lists
            updateLists();
        }

        // Update anchor and tag lists
        function updateLists() {
            // Update anchor list
            const anchorList = document.getElementById('anchorList');
            anchorList.innerHTML = anchors.map(anchor => `
                <li class="device-item">
                    <span class="status-indicator ${anchor.status}"></span>
                    <strong>${anchor.id}</strong> - ${anchor.name}
                    <div class="distance-info">V·ªã tr√≠: (${anchor.x.toFixed(1)}m, ${anchor.y.toFixed(1)}m)</div>
                </li>
            `).join('');

            // Update tag list with UWB info
            const tagList = document.getElementById('tagList');
            tagList.innerHTML = tags.map(tag => {
                const { anchor, distance } = findNearestAnchor(tag);
                const uwbInfo = tag.uwb ? 
                    `A0: ${tag.uwb.A0?.toFixed(2) || '-'}m, A1: ${tag.uwb.A1?.toFixed(2) || '-'}m, A2: ${tag.uwb.A2?.toFixed(2) || '-'}m` : 
                    'No UWB data';
                const statusClass = tag.status === 'offline' ? 'offline' : 'online';
                const statusIcon = tag.status === 'offline' ? '‚ö™' : 'üî¥';
                const batteryInfo = tag.battery !== undefined ? `üîã ${Math.round(tag.battery)}%` : '';
                return `
                    <li class="device-item tag" style="border-left-color: ${tag.status === 'offline' ? '#9E9E9E' : '#f44336'}">
                        <span class="status-indicator ${statusClass}"></span>
                        ${statusIcon} <strong>${tag.id}</strong> - ${tag.name} ${batteryInfo}
                        <div class="distance-info">
                            üìç V·ªã tr√≠: (${tag.x.toFixed(2)}m, ${tag.y.toFixed(2)}m)<br>
                            üìè UWB: ${uwbInfo}<br>
                            üéØ G·∫ßn nh·∫•t: ${anchor ? anchor.id : 'N/A'} (${distance.toFixed(2)}m)
                        </div>
                    </li>
                `;
            }).join('');

            // Update statistics
            document.getElementById('totalAnchors').textContent = anchors.length;
            document.getElementById('totalTags').textContent = tags.length;
            document.getElementById('activeTags').textContent = tags.filter(t => t.status === 'online').length;
            
            const onlineTags = tags.filter(t => t.status === 'online');
            const avgDist = onlineTags.length > 0 ? onlineTags.reduce((sum, tag) => {
                const { distance } = findNearestAnchor(tag);
                return sum + distance;
            }, 0) / onlineTags.length : 0;
            document.getElementById('avgDistance').textContent = avgDist.toFixed(2);
        }

        // Animation loop
        function animate() {
            updateTagPositions();
            draw();
            requestAnimationFrame(animate);
        }

        // Scale slider
        document.getElementById('scaleSlider').addEventListener('input', (e) => {
            scale = parseInt(e.target.value);
            document.getElementById('scaleValue').textContent = scale;
            draw();
        });

        // Reset view
        function resetView() {
            scale = 20;
            document.getElementById('scaleSlider').value = 20;
            document.getElementById('scaleValue').textContent = 20;
            
            // ‚úÖ Kh√¥ng reset tags n·ªØa, gi·ªØ nguy√™n tags t·ª´ UWB
            // Tags s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t t·ª± ƒë·ªông t·ª´ WebSocket
            
            draw();
        }

        // Toggle animation
        function toggleAnimation() {
            isAnimating = !isAnimating;
            document.getElementById('animationBtn').textContent = isAnimating ? '‚è∏ D·ª´ng' : '‚ñ∂Ô∏è Ch·∫°y';
        }

        // Logout function
        function logout() {
            sessionStorage.removeItem('isLoggedIn');
            sessionStorage.removeItem('username');
            window.location.href = 'login.html';
        }

        // ==========================================
        // WEBSOCKET REALTIME UPDATES
        // ==========================================
        
        let stompClient = null;
        let helmetPositions = {}; // Store helmet positions by MAC
        let lastPositions = {}; // üÜï Store last valid positions for smoothing
        
        /**
         * üéØ C·ªê ƒê·ªäNH V·ªä TR√ç ANCHOR CHO UWB POSITIONING
         * H·ªó tr·ª£ 4 anchors: A0, A1, A2, A3 trong kh√¥ng gian 20m x 20m
         * 
         * Layout th·ª±c t·∫ø (nh√¨n t·ª´ m√†n h√¨nh - tr·ª•c Y h∆∞·ªõng l√™n):
         *      20m ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         *          ‚îÇ                             ‚îÇ
         *      17m ‚îÇ  A0 (3,17)       A3 (17,17) ‚îÇ
         *          ‚îÇ                             ‚îÇ
         *          ‚îÇ                             ‚îÇ
         *          ‚îÇ         [TAG1]              ‚îÇ
         *          ‚îÇ                             ‚îÇ
         *          ‚îÇ                             ‚îÇ
         *       3m ‚îÇ  A1 (3,3)        A2 (17,3)  ‚îÇ
         *          ‚îÇ                             ‚îÇ
         *       0m ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         *          0m         10m            20m
         */
        const UWB_ANCHORS = {
            A0: { x: 3, y: 17 },   // Anchor A0 - g√≥c tr√™n tr√°i
            A1: { x: 3, y: 3 },    // Anchor A1 - g√≥c d∆∞·ªõi tr√°i  
            A2: { x: 17, y: 3 },   // Anchor A2 - g√≥c d∆∞·ªõi ph·∫£i
            A3: { x: 17, y: 17 }   // Anchor A3 - g√≥c tr√™n ph·∫£i (üÜï)
        };
        
        // üÜï Smoothing factor (0 = no smoothing, 0.8 = very smooth)
        const POSITION_SMOOTHING = 0.3;
        const MAX_JUMP_DISTANCE = 5; // meters - max allowed jump per update
        
        /**
         * üÜï T√≠nh bounding box c·ªßa c√°c anchor ƒëang k·∫øt n·ªëi
         * Tag ch·ªâ ƒë∆∞·ª£c n·∫±m trong v√πng n√†y
         */
        function getAnchorBoundingBox(anchorList) {
            if (anchorList.length === 0) return null;
            
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            for (const anchor of anchorList) {
                minX = Math.min(minX, anchor.x);
                maxX = Math.max(maxX, anchor.x);
                minY = Math.min(minY, anchor.y);
                maxY = Math.max(maxY, anchor.y);
            }
            
            // Th√™m padding nh·ªè (10% k√≠ch th∆∞·ªõc v√πng) ƒë·ªÉ cho ph√©p tag n·∫±m s√°t bi√™n
            const paddingX = (maxX - minX) * 0.1;
            const paddingY = (maxY - minY) * 0.1;
            
            return {
                minX: minX - paddingX,
                maxX: maxX + paddingX,
                minY: minY - paddingY,
                maxY: maxY + paddingY
            };
        }
        
        /**
         * üÜï Gi·ªõi h·∫°n v·ªã tr√≠ trong bounding box c·ªßa anchors
         */
        function constrainToAnchorZone(x, y, anchorList) {
            const bbox = getAnchorBoundingBox(anchorList);
            if (!bbox) return { x, y };
            
            return {
                x: Math.max(bbox.minX, Math.min(bbox.maxX, x)),
                y: Math.max(bbox.minY, Math.min(bbox.maxY, y))
            };
        }
        
        /**
         * T√≠nh t·ªça ƒë·ªô tag t·ª´ UWB data s·ª≠ d·ª•ng Nonlinear Least Squares v·ªõi Gradient Descent
         * Ph∆∞∆°ng ph√°p n√†y ch√≠nh x√°c h∆°n Linear Least Squares
         */
        function calculatePositionFromUWB(uwb, mac) {
            // üÜï S·ª≠ d·ª•ng anchors t·ª´ database thay v√¨ hardcoded UWB_ANCHORS
            // T√¨m anchors ƒëang k·∫øt n·ªëi d·ª±a tr√™n UWB data
            const anchorOrder = ['A0', 'A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7']; // Support more anchors
            const anchorList = [];
            const distances = [];
            
            for (const key of anchorOrder) {
                if (uwb[key] !== undefined && uwb[key] > 0 && uwb[key] < 50) {
                    // üÜï T√¨m anchor t·ª´ database (anchors array) thay v√¨ hardcoded
                    const dbAnchor = anchors.find(a => a.id === key);
                    if (dbAnchor) {
                        anchorList.push({ x: dbAnchor.x, y: dbAnchor.y, name: key });
                        distances.push(uwb[key]);
                    } else {
                        // Fallback to hardcoded if not found in DB
                        if (UWB_ANCHORS[key]) {
                            anchorList.push({ ...UWB_ANCHORS[key], name: key });
                            distances.push(uwb[key]);
                        }
                    }
                }
            }
            
            // C·∫ßn √≠t nh·∫•t 3 anchors
            if (anchorList.length < 3) {
                console.log(`‚ö†Ô∏è Not enough anchors: ${anchorList.length}/3 required`);
                return lastPositions[mac] || null;
            }
            
            console.log(`üìè UWB distances for ${mac}:`, 
                anchorList.map((a, i) => `${a.name}=${distances[i].toFixed(2)}m`).join(', '));
            
            // üéØ Gradient Descent ƒë·ªÉ minimize error function
            // Error = Œ£ (sqrt((x-xi)¬≤ + (y-yi)¬≤) - ri)¬≤
            
            // Kh·ªüi t·∫°o v·ªã tr√≠ ban ƒë·∫ßu: d√πng v·ªã tr√≠ tr∆∞·ªõc ho·∫∑c centroid
            let x, y;
            if (lastPositions[mac]) {
                x = lastPositions[mac].x;
                y = lastPositions[mac].y;
            } else {
                // Weighted centroid l√†m ƒëi·ªÉm kh·ªüi ƒë·∫ßu
                let totalW = 0;
                x = 0; y = 0;
                for (let i = 0; i < anchorList.length; i++) {
                    const w = 1 / (distances[i] * distances[i]);
                    x += anchorList[i].x * w;
                    y += anchorList[i].y * w;
                    totalW += w;
                }
                x /= totalW;
                y /= totalW;
            }
            
            // Gradient descent v·ªõi learning rate v√† iterations
            const learningRate = 0.5;
            const iterations = 50;
            
            for (let iter = 0; iter < iterations; iter++) {
                let gradX = 0, gradY = 0;
                
                for (let i = 0; i < anchorList.length; i++) {
                    const dx = x - anchorList[i].x;
                    const dy = y - anchorList[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 0.001) { // Tr√°nh chia cho 0
                        const error = dist - distances[i];
                        // Weight: anchor g·∫ßn h∆°n c√≥ weight cao h∆°n
                        const weight = 1 / (distances[i] * distances[i]);
                        
                        gradX += weight * error * (dx / dist);
                        gradY += weight * error * (dy / dist);
                    }
                }
                
                // C·∫≠p nh·∫≠t v·ªã tr√≠
                x -= learningRate * gradX;
                y -= learningRate * gradY;
                
                // üÜï Gi·ªõi h·∫°n trong v√πng anchor ƒëang k·∫øt n·ªëi (kh√¥ng ph·∫£i to√†n b·ªô area)
                const constrained = constrainToAnchorZone(x, y, anchorList);
                x = constrained.x;
                y = constrained.y;
            }
            
            console.log(`üìç Gradient descent position (${anchorList.length} anchors): (${x.toFixed(2)}, ${y.toFixed(2)})`);
            
            // Smoothing v·ªõi v·ªã tr√≠ tr∆∞·ªõc
            const lastPos = lastPositions[mac];
            if (lastPos) {
                const jumpDist = Math.sqrt((x - lastPos.x) ** 2 + (y - lastPos.y) ** 2);
                
                if (jumpDist > MAX_JUMP_DISTANCE) {
                    console.log(`‚ö†Ô∏è Large jump detected: ${jumpDist.toFixed(2)}m, applying heavy smoothing`);
                    x = lastPos.x + (x - lastPos.x) * 0.3;
                    y = lastPos.y + (y - lastPos.y) * 0.3;
                } else if (jumpDist > 1) {
                    // Smoothing trung b√¨nh cho di chuy·ªÉn > 1m
                    x = lastPos.x * POSITION_SMOOTHING + x * (1 - POSITION_SMOOTHING);
                    y = lastPos.y * POSITION_SMOOTHING + y * (1 - POSITION_SMOOTHING);
                }
                // Di chuy·ªÉn < 1m: kh√¥ng smoothing, ƒë·ªÉ tag ph·∫£n h·ªìi nhanh
            }
            
            // üÜï Gi·ªõi h·∫°n cu·ªëi c√πng trong v√πng anchor
            const finalConstrained = constrainToAnchorZone(x, y, anchorList);
            x = finalConstrained.x;
            y = finalConstrained.y;
            
            // L∆∞u v·ªã tr√≠ cu·ªëi
            lastPositions[mac] = { x, y };
            
            return { x, y };
        }
        
        /**
         * X·ª≠ l√Ω helmet data t·ª´ WebSocket
         */
        function handleHelmetData(data) {
            console.log('üì° Received helmet data:', data.mac, data.uwb);
            
            // Ki·ªÉm tra c√≥ UWB data kh√¥ng - check ready flag ho·∫∑c s·ªë anchors
            if (!data.uwb) {
                console.log('‚ö†Ô∏è No UWB data for', data.mac);
                return;
            }
            
            // Ki·ªÉm tra ready flag (backend t·ª± set d·ª±a tr√™n s·ªë anchors h·ª£p l·ªá)
            const isReady = data.uwb.ready === 1 || data.uwbReady === true;
            if (!isReady) {
                console.log('‚ö†Ô∏è UWB not ready for', data.mac, 'anchorCount:', data.uwb.anchorCount);
                return;
            }
            
            // T√≠nh t·ªça ƒë·ªô t·ª´ UWB
            const position = calculatePositionFromUWB(data.uwb, data.mac);
            
            if (!position) {
                return;
            }
            
            // C·∫≠p nh·∫≠t ho·∫∑c t·∫°o tag m·ªõi
            let tag = tags.find(t => t.helmet === data.mac);
            
            if (tag) {
                // C·∫≠p nh·∫≠t v·ªã tr√≠
                tag.x = position.x;
                tag.y = position.y;
                tag.status = 'online';
                console.log(`üîÑ Updated tag ${tag.id} position`);
            } else {
                // T·∫°o tag m·ªõi
                const newTag = {
                    id: 'T' + (tags.length + 1),
                    name: data.employeeName || data.mac,
                    x: position.x,
                    y: position.y,
                    vx: 0,
                    vy: 0,
                    status: 'online',
                    helmet: data.mac
                };
                tags.push(newTag);
                console.log(`‚ûï Created new tag ${newTag.id} for ${data.mac}`);
            }
            
            // L∆∞u v√†o cache
            helmetPositions[data.mac] = {
                position: position,
                timestamp: Date.now(),
                battery: data.battery,
                uwb: data.uwb
            };
        }
        
        /**
         * K·∫øt n·ªëi WebSocket
         */
        function connectWebSocket() {
            console.log('üîå Connecting to WebSocket...');
            
            const socket = new SockJS('/ws');
            stompClient = Stomp.over(socket);
            
            // Disable debug logs
            stompClient.debug = null;
            
            stompClient.connect({}, function(frame) {
                console.log('‚úÖ WebSocket connected:', frame);
                
                // üéØ Subscribe to REALTIME POSITION updates (with UWB data)
                stompClient.subscribe('/topic/helmet/position', function(message) {
                    try {
                        const data = JSON.parse(message.body);
                        handleRealtimePosition(data);
                    } catch (e) {
                        console.error('‚ùå Error parsing position data:', e);
                    }
                });
                
                // Also subscribe to legacy helmet data (for backward compatibility)
                stompClient.subscribe('/topic/helmet/data', function(message) {
                    try {
                        const data = JSON.parse(message.body);
                        // Only use if no UWB data in position topic
                        if (!data.uwb) {
                            handleHelmetData(data);
                        }
                    } catch (e) {
                        console.error('‚ùå Error parsing helmet data:', e);
                    }
                });
                
            }, function(error) {
                console.error('‚ùå WebSocket error:', error);
                
                // Reconnect sau 5s
                setTimeout(() => {
                    console.log('üîÑ Reconnecting WebSocket...');
                    connectWebSocket();
                }, 5000);
            });
        }
        
        /**
         * üéØ X·ª≠ l√Ω realtime position v·ªõi UWB data
         */
        function handleRealtimePosition(data) {
            console.log('üìç Realtime position received:', data);
            
            // Ki·ªÉm tra status offline (tag chuy·ªÉn m√†u x√°m)
            if (data.status === 'offline') {
                let tag = tags.find(t => t.helmet === data.mac);
                if (tag) {
                    tag.status = 'offline';
                    console.log(`‚ö™ Tag ${tag.id} is now OFFLINE (grey)`);
                }
                draw();
                return;
            }
            
            // Ki·ªÉm tra c√≥ UWB data kh√¥ng
            // Support c·∫£ 2 format: {uwb: {...}, uwbReady: true} ho·∫∑c {uwb: {ready: 1, ...}}
            const uwbData = data.uwb;
            const isReady = data.uwbReady === true || (uwbData && uwbData.ready === 1);
            
            if (!uwbData) {
                console.log('‚ö†Ô∏è No UWB data for', data.mac);
                return;
            }
            
            if (!isReady) {
                console.log('‚ö†Ô∏è UWB not ready for', data.mac, 'ready=', uwbData?.ready);
                return;
            }
            
            console.log('üì° UWB Data:', uwbData);
            
            // T√≠nh t·ªça ƒë·ªô t·ª´ UWB
            const position = calculatePositionFromUWB(uwbData, data.mac);
            
            if (!position) {
                console.log('‚ö†Ô∏è Could not calculate position');
                return;
            }
            
            // üìä Track last data time for offline detection
            tagLastDataTime[data.mac] = Date.now();
            
            // C·∫≠p nh·∫≠t ho·∫∑c t·∫°o tag m·ªõi
            let tag = tags.find(t => t.helmet === data.mac);
            
            if (tag) {
                // Smooth movement - interpolate to new position
                const smoothFactor = 0.3; // 0 = no change, 1 = instant jump
                tag.x = tag.x + (position.x - tag.x) * smoothFactor;
                tag.y = tag.y + (position.y - tag.y) * smoothFactor;
                tag.status = 'online';
                tag.battery = data.battery;
                tag.uwb = uwbData;
                console.log(`üîÑ Updated tag ${tag.id} to (${tag.x.toFixed(2)}, ${tag.y.toFixed(2)})`);
            } else {
                // T·∫°o tag m·ªõi
                const newTag = {
                    id: 'TAG' + (tags.length + 1),
                    name: data.employeeName || data.mac.slice(-4),
                    x: position.x,
                    y: position.y,
                    vx: 0,
                    vy: 0,
                    status: 'online',
                    helmet: data.mac,
                    battery: data.battery,
                    uwb: uwbData
                };
                tags.push(newTag);
                console.log(`‚ûï Created new tag ${newTag.id} for ${data.mac} at (${position.x.toFixed(2)}, ${position.y.toFixed(2)})`);
            }
            
            // L∆∞u v√†o cache (for display purposes only)
            helmetPositions[data.mac] = {
                position: position,
                timestamp: Date.now(),
                battery: data.battery,
                uwb: uwbData
            };
            
            // Trigger redraw
            draw();
        }
        
        /**
         * ‚è∞ Check v√† chuy·ªÉn tag th√†nh offline n·∫øu kh√¥ng nh·∫≠n data trong 30s
         * Ch·∫°y m·ªói 5 gi√¢y
         */
        function checkTagsOfflineStatus() {
            const now = Date.now();
            let needRedraw = false;
            
            tags.forEach(tag => {
                const lastDataTime = tagLastDataTime[tag.helmet];
                
                // N·∫øu tag ƒëang online nh∆∞ng kh√¥ng nh·∫≠n data trong 30s
                if (tag.status === 'online' && lastDataTime) {
                    const timeSinceLastData = now - lastDataTime;
                    if (timeSinceLastData > OFFLINE_TIMEOUT_MS) {
                        tag.status = 'offline';
                        console.log(`‚ö™ Tag ${tag.id} went OFFLINE (no data for ${Math.round(timeSinceLastData/1000)}s)`);
                        needRedraw = true;
                    }
                }
            });
            
            if (needRedraw) {
                draw();
            }
        }
        
        // Start offline check interval
        setInterval(checkTagsOfflineStatus, 5000); // Check every 5 seconds
        
        // ==========================================
        // END WEBSOCKET
        // ==========================================
        
        // Auto-refresh anchors every 10 seconds
        function startAnchorSync() {
            console.log('üîÑ Starting anchor sync...');
            loadAnchorsFromDatabase(); // Initial load
            setInterval(() => {
                console.log('üîÑ Refreshing anchors...');
                loadAnchorsFromDatabase();
            }, 10000); // Refresh every 10s
        }
        
        /**
         * üìã Load all tags (online + offline) t·ª´ DB khi m·ªü trang
         * Offline tags hi·ªÉn th·ªã m√†u x√°m ·ªü v·ªã tr√≠ cu·ªëi c√πng
         */
        async function loadTagPositions() {
            console.log('üìã Loading tag positions from DB...');
            try {
                const response = await fetch('/api/positioning/tags');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const tagsData = await response.json();
                console.log('üìã Loaded', tagsData.length, 'tags from DB');
                
                tagsData.forEach(tagData => {
                    // B·ªè qua n·∫øu kh√¥ng c√≥ v·ªã tr√≠
                    if (tagData.x == null || tagData.y == null) {
                        console.log('‚ö†Ô∏è Skipping tag without position:', tagData.mac);
                        return;
                    }
                    
                    // Ki·ªÉm tra tag ƒë√£ t·ªìn t·∫°i ch∆∞a
                    let existingTag = tags.find(t => t.helmet === tagData.mac);
                    
                    if (existingTag) {
                        // Update existing tag
                        existingTag.status = tagData.isOnline ? 'online' : 'offline';
                        existingTag.battery = tagData.battery;
                        console.log(`üîÑ Updated tag ${existingTag.id} status: ${existingTag.status}`);
                    } else {
                        // Create new tag
                        const newTag = {
                            id: 'TAG' + (tags.length + 1),
                            name: tagData.employeeName || tagData.mac?.slice(-4) || 'Unknown',
                            x: tagData.x,
                            y: tagData.y,
                            vx: 0,
                            vy: 0,
                            status: tagData.isOnline ? 'online' : 'offline',
                            helmet: tagData.mac,
                            battery: tagData.battery,
                            uwb: {
                                A0: tagData.distanceA0,
                                A1: tagData.distanceA1,
                                A2: tagData.distanceA2
                            }
                        };
                        tags.push(newTag);
                        console.log(`‚ûï Loaded tag ${newTag.id} (${tagData.isOnline ? 'online' : 'offline'}) at (${tagData.x?.toFixed(2)}, ${tagData.y?.toFixed(2)})`);
                    }
                });
                
                // Redraw ƒë·ªÉ hi·ªÉn th·ªã tags
                draw();
                
            } catch (error) {
                console.error('‚ùå Error loading tag positions:', error);
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üìç Page loaded, initializing...');
            
            // Check auth if function exists
            if (typeof checkAuth === 'function') {
                checkAuth();
            }
            
            // Set canvas size
            canvas.width = areaSize * scale + 80;
            canvas.height = areaSize * scale + 80;
            
            loadSafeZones(); // Load safe zones for color detection
            startAnchorSync(); // Load anchors from DB
            loadTagPositions(); // üìã Load all tags (online + offline) from DB
            connectWebSocket(); // Connect WebSocket for realtime UWB data
            animate();
            
            // Start updating demo tag distances
            updateDemoTagDistances();
            
            // ‚è∞ Refresh tag status every 10 seconds (sync offline status from backend)
            setInterval(refreshTagStatus, 10000);
        });
        
        /**
         * ‚è∞ Refresh tag status t·ª´ backend
         * ƒê·ªìng b·ªô tr·∫°ng th√°i online/offline v·ªõi location.html
         */
        async function refreshTagStatus() {
            try {
                const response = await fetch('/api/positioning/tags');
                if (!response.ok) return;
                
                const tagsData = await response.json();
                
                tagsData.forEach(tagData => {
                    let tag = tags.find(t => t.helmet === tagData.mac);
                    if (tag) {
                        const newStatus = tagData.isOnline ? 'online' : 'offline';
                        if (tag.status !== newStatus) {
                            console.log(`üîÑ Tag ${tag.id} status: ${tag.status} ‚Üí ${newStatus}`);
                            tag.status = newStatus;
                        }
                    }
                });
                
                draw();
            } catch (error) {
                console.error('‚ùå Error refreshing tag status:', error);
            }
        }

        // ==========================================
        // DEMO TAG DISTANCE LINES
        // ==========================================
        function updateDemoTagDistances() {
            const canvasWrapper = document.getElementById('canvasWrapper');
            const canvas = document.getElementById('canvas2d');
            
            if (!canvasWrapper || !canvas) {
                console.error('‚ùå Canvas wrapper or canvas not found');
                return;
            }
            
            console.log('‚úÖ Starting demo tag distance updates');
            
            // Create distance lines container if not exists
            let linesContainer = document.getElementById('demoDistanceLines');
            if (!linesContainer) {
                linesContainer = document.createElement('div');
                linesContainer.id = 'demoDistanceLines';
                linesContainer.style.position = 'absolute';
                linesContainer.style.top = '0';
                linesContainer.style.left = '0';
                linesContainer.style.width = '100%';
                linesContainer.style.height = '100%';
                linesContainer.style.pointerEvents = 'none';
                linesContainer.style.zIndex = '15';
                canvasWrapper.appendChild(linesContainer);
                console.log('‚úÖ Created distance lines container');
            }
            
            // Update every 100ms for smooth animation
            setInterval(() => {
                if (!isAnimating) {
                    linesContainer.innerHTML = '';
                    return;
                }
                
                // Get demo tag positions
                const tag1 = document.querySelector('.demo-tag-1');
                const tag2 = document.querySelector('.demo-tag-2');
                const tag3 = document.querySelector('.demo-tag-3');
                
                if (!tag1 || !tag2 || !tag3) {
                    console.warn('‚ö†Ô∏è Demo tags not found');
                    return;
                }
                
                // Get anchor positions from canvas (A1, A2, A3)
                // A1 (2, 20), A2 (5, 2), A3 (20, 17)
                const anchorPositions = [
                    { id: 'A1', x: 2, y: 20 },
                    { id: 'A2', x: 5, y: 2 },
                    { id: 'A3', x: 20, y: 17 }
                ];
                
                const demoTags = [
                    { element: tag1, name: 'TAG1' },
                    { element: tag2, name: 'TAG2' },
                    { element: tag3, name: 'TAG3' }
                ];
                
                // Clear previous lines
                linesContainer.innerHTML = '';
                
                // Draw lines from each tag to nearest anchor
                demoTags.forEach(tag => {
                    const wrapperRect = canvasWrapper.getBoundingClientRect();
                    const tagRect = tag.element.getBoundingClientRect();
                    
                    // Tag position relative to wrapper
                    const tagX = tagRect.left - wrapperRect.left + tagRect.width / 2;
                    const tagY = tagRect.top - wrapperRect.top + tagRect.height / 2;
                    
                    // Convert tag pixel position to meters
                    const tagMeterX = (tagX - 40) / scale;
                    const tagMeterY = (canvas.height - tagY - 40) / scale;
                    
                    // Find nearest anchor
                    let nearestAnchor = null;
                    let minDistance = Infinity;
                    
                    anchorPositions.forEach(anchor => {
                        const dx = tagMeterX - anchor.x;
                        const dy = tagMeterY - anchor.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestAnchor = anchor;
                        }
                    });
                    
                    if (!nearestAnchor) return;
                    
                    // Convert anchor meter position to pixels
                    const anchorX = nearestAnchor.x * scale + 40;
                    const anchorY = canvas.height - (nearestAnchor.y * scale + 40);
                    
                    // Draw line
                    const dx = anchorX - tagX;
                    const dy = anchorY - tagY;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
const line = document.createElement('div');
                    line.className = 'distance-line';
                    line.style.left = tagX + 'px';
                    line.style.top = tagY + 'px';
                    line.style.width = length + 'px';
                    line.style.transform = `rotate(${angle}deg)`;
                    linesContainer.appendChild(line);
                    
                    // Draw distance label
                    const label = document.createElement('div');
                    label.className = 'distance-label';
                    label.textContent = minDistance.toFixed(1) + 'm ‚Üí ' + nearestAnchor.id;
                    label.style.left = (tagX + dx / 2 - 35) + 'px';
                    label.style.top = (tagY + dy / 2 - 10) + 'px';
                    linesContainer.appendChild(label);
                });
                
            }, 100);
        }
    </script>
    
    <!-- Mobile Navigation & PWA -->
    <script src="js/mobile-nav.js"></script>
    <script src="js/pwa-init.js"></script>
    
    <!-- Voice Assistant -->
    <script src="js/voice-assistant.js?v=361nav"></script>
</body>
</html>
