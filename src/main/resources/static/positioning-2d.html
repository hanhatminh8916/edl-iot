<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>S∆° ƒê·ªì 2D Positioning - EDL SafeWork v188 (Realtime UWB)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="css/style.css?v=187">
    <link rel="stylesheet" href="css/location.css?v=187">
    <style>
        .main-content {
            padding: 20px;
        }

        .canvas-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .canvas-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .canvas-header h2 {
            margin: 0;
            color: #333;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .control-group label {
            font-size: 14px;
            color: #666;
        }

        .control-group input[type="range"] {
            width: 150px;
        }

        .control-group span {
            min-width: 40px;
            font-weight: bold;
            color: #333;
        }

        #canvas2d {
            border: 2px solid #e0e0e0;
            border-radius: 4px;
            background: #f5f5f5;
            cursor: crosshair;
            display: block;
            margin: 0 auto;
        }

        .legend {
            display: flex;
            gap: 30px;
            margin-top: 15px;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 4px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
        }

        .legend-color.anchor {
            background: #2196F3;
        }

        .legend-color.tag {
            background: #f44336;
        }
        
        .legend-color.tag-offline {
            background: #9E9E9E;
        }

        /* ===== HIDE DEMO TAGS - NOW USING REALTIME UWB ===== */
        .demo-tag {
            display: none !important; /* ‚úÖ ·∫®n demo tags */
        }

        /* Distance lines for demo tags */
        .distance-line {
            position: absolute;
            background: rgba(76, 175, 80, 0.3);
            height: 2px;
            transform-origin: left center;
            z-index: 5;
            pointer-events: none;
        }

        .distance-label {
            position: absolute;
            background: white;
            border: 1px solid #4CAF50;
            padding: 2px 6px;
            font-size: 11px;
            font-weight: bold;
            color: #333;
            border-radius: 3px;
            z-index: 6;
            pointer-events: none;
            white-space: nowrap;
        }

        .info-panel {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .info-section {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
        }

        .info-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 16px;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 8px;
        }

        .device-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .device-item {
            padding: 8px;
            margin-bottom: 5px;
            background: white;
            border-radius: 4px;
            border-left: 3px solid #2196F3;
            font-size: 14px;
        }

        .device-item.tag {
            border-left-color: #f44336;
        }

        .device-item strong {
            color: #333;
        }

        .distance-info {
            font-size: 12px;
            color: #666;
            margin-top: 3px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
        }

        .btn-secondary {
            background: #2196F3;
            color: white;
        }

        .btn-secondary:hover {
            background: #0b7dda;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .status-indicator.online {
            background: #4CAF50;
        }

        .status-indicator.offline {
            background: #f44336;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-left">
            <div class="logo">
                <i class="fas fa-hard-hat"></i>
                <span>EDL SafeWork</span>
            </div>
        </div>
        <div class="header-right">
            <div class="user-profile">
                <i class="fas fa-user-circle"></i>
                <span id="usernameDisplay">vku123</span>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <nav class="nav-menu">
                <a href="index.html" class="nav-item">
                    <i class="fas fa-chart-line"></i>
                    <span>T·ªïng quan</span>
                </a>
                <a href="location.html" class="nav-item">
                    <i class="fas fa-map-marker-alt"></i>
                    <span>Gi√°m s√°t v·ªã tr√≠</span>
                </a>
                <a href="positioning-2d.html" class="nav-item active">
                    <i class="fas fa-ruler-combined"></i>
                    <span>S∆° ƒê·ªì 2D</span>
                </a>
                <a href="employees.html" class="nav-item">
                    <i class="fas fa-users"></i>
                    <span>Qu·∫£n l√Ω c√¥ng nh√¢n</span>
                </a>
                <a href="alerts.html" class="nav-item">
                    <i class="fas fa-exclamation-triangle"></i>
                    <span>C·∫£nh b√°o</span>
                </a>
                <a href="reports.html" class="nav-item">
                    <i class="fas fa-chart-bar"></i>
                    <span>B√°o c√°o</span>
                </a>
                <a href="#" class="nav-item">
                    <i class="fas fa-cog"></i>
                    <span>C√†i ƒë·∫∑t</span>
                </a>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Page Header -->
            <div class="page-header">
                <div>
                    <h1>üìê S∆° ƒê·ªì 2D Positioning System</h1>
                    <p id="viewMode" style="font-size: 16px; color: #666; margin-top: 8px;">
                        <i class="fas fa-globe"></i> Ch·∫ø ƒë·ªô: T·ªïng quan to√†n b·ªô khu v·ª±c
                    </p>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button class="btn btn-secondary" onclick="switchToOverview()" id="btnOverview" style="display:none;">
                        <i class="fas fa-th"></i> Xem t·ªïng quan
                    </button>
                    <button class="btn btn-primary" onclick="switchToZone()" id="btnBackToZone" style="display:none;">
                        <i class="fas fa-map-marked-alt"></i> Quay l·∫°i <span id="zoneName"></span>
                    </button>
                </div>
            </div>

        <!-- Canvas Container -->
        <div class="canvas-container">
            <div class="canvas-header">
                <h2 id="areaTitle">Khu V·ª±c Gi√°m S√°t (20m √ó 20m)</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>T·ª∑ l·ªá:</label>
                        <input type="range" id="scaleSlider" min="10" max="40" value="20" step="1">
                        <span id="scaleValue">20</span> px/m
                    </div>
                    <button class="btn btn-secondary" onclick="resetView()">Reset View</button>
                    <button class="btn btn-primary" onclick="toggleAnimation()">
                        <span id="animationBtn">‚è∏ D·ª´ng</span>
                    </button>
                </div>
            </div>
            
            <!-- Canvas wrapper with demo tags -->
            <div id="canvasWrapper" style="position: relative; display: inline-block;">
                <canvas id="canvas2d" width="800" height="800"></canvas>
                
                <!-- Demo animated tags -->
                <div class="demo-tag demo-tag-1" data-label="TAG1"></div>
            </div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color anchor"></div>
                    <span><strong>Anchor</strong> - Thi·∫øt b·ªã ƒë·ªãnh v·ªã c·ªë ƒë·ªãnh (UWB)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color tag"></div>
                    <span><strong>Tag Online</strong> - ƒêang ho·∫°t ƒë·ªông</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color tag-offline"></div>
                    <span><strong>Tag Offline</strong> - M·∫•t k·∫øt n·ªëi (v·ªã tr√≠ cu·ªëi)</span>
                </div>
                <div class="legend-item">
                    <span>üìè ƒê∆∞·ªùng cam: Kho·∫£ng c√°ch UWB realtime (meter)</span>
                </div>
            </div>
        </div>

        <!-- Info Panel -->
        <div class="info-panel">
            <h2>Th√¥ng Tin Chi Ti·∫øt</h2>
            <div class="info-grid">
                <div class="info-section">
                    <h3>üìç Danh S√°ch Anchor</h3>
                    <ul class="device-list" id="anchorList"></ul>
                </div>
                <div class="info-section">
                    <h3>üè∑Ô∏è Danh S√°ch Tag</h3>
                    <ul class="device-list" id="tagList"></ul>
                </div>
                <div class="info-section">
                    <h3>üìä Th·ªëng K√™</h3>
                    <div style="padding: 10px;">
                        <p><strong>T·ªïng Anchor:</strong> <span id="totalAnchors">0</span></p>
                        <p><strong>T·ªïng Tag:</strong> <span id="totalTags">0</span></p>
                        <p><strong>Tag Ho·∫°t ƒê·ªông:</strong> <span id="activeTags">0</span></p>
                        <p><strong>Kho·∫£ng C√°ch Trung B√¨nh:</strong> <span id="avgDistance">0</span> m</p>
                    </div>
                </div>
            </div>
        </div>
        </main>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
    <script src="js/auth.js"></script>
    <script>
        const canvas = document.getElementById('canvas2d');
        const ctx = canvas.getContext('2d');
        
        // Configuration
        let scale = 20; // pixels per meter
        const areaSize = 20; // 20m √ó 20m
        let isAnimating = false; // ‚úÖ T·∫Øt animation demo, ch·ªâ d√πng UWB realtime

        // Zone filtering
        let currentZoneId = null;
        let currentZone = null;
        let previousZoneId = null; // Store previous zone for navigation

        // Check if zone parameter exists in URL
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('zone')) {
            currentZoneId = urlParams.get('zone');
            previousZoneId = currentZoneId; // Remember this zone
            loadZoneInfo(currentZoneId);
        }

        // Anchors - will be loaded from database
        let anchors = [];
        
        // Reference point for coordinate conversion (use first anchor as reference or fixed point)
        let referencePoint = null;
        
        // Switch back to overview mode
        function switchToOverview() {
            currentZoneId = null; // Clear current zone but keep previousZoneId
            loadAnchorsFromDatabase(); // Reload all anchors
            
            // Update UI
            document.getElementById('viewMode').innerHTML = `
                <i class="fas fa-globe"></i> Ch·∫ø ƒë·ªô: T·ªïng quan to√†n b·ªô khu v·ª±c
            `;
            document.getElementById('areaTitle').textContent = 'Khu V·ª±c Gi√°m S√°t (20m √ó 20m)';
            document.getElementById('btnOverview').style.display = 'none';
            
            // Show back to zone button if there was a previous zone
            if (previousZoneId && currentZone) {
                document.getElementById('btnBackToZone').style.display = 'inline-block';
                document.getElementById('zoneName').textContent = currentZone.name;
            }
            
            // Update URL without zone parameter
            window.history.pushState({}, '', 'positioning-2d.html');
        }
        
        // Switch back to previous zone
        function switchToZone() {
            if (previousZoneId) {
                window.location.href = `positioning-2d.html?zone=${previousZoneId}`;
            }
        }
        
        // Load zone information
        async function loadZoneInfo(zoneId) {
            try {
                const response = await fetch(`/api/zones/${zoneId}`);
                if (response.ok) {
                    currentZone = await response.json();
                    previousZoneId = zoneId; // Remember this zone
                    
                    document.getElementById('viewMode').innerHTML = `
                        <i class="fas fa-map-marked-alt"></i> Ch·∫ø ƒë·ªô: Khu v·ª±c chi ti·∫øt "<strong>${currentZone.name}</strong>"
                    `;
                    document.getElementById('areaTitle').textContent = `${currentZone.name} (Khu v·ª±c chi ti·∫øt)`;
                    document.getElementById('btnOverview').style.display = 'inline-block';
                    document.getElementById('btnBackToZone').style.display = 'none'; // Hide when in zone view
                    console.log('‚úÖ Viewing zone:', currentZone);
                }
            } catch (error) {
                console.error('Error loading zone info:', error);
            }
        }
        
        // Convert lat/lng to local x/y coordinates (meters)
        function latLngToXY(lat, lng, refLat, refLng) {
            // 1 degree latitude ‚âà 111,000 meters
            // 1 degree longitude ‚âà 111,000 * cos(latitude) meters
            const latDiff = (lat - refLat) * 111000;
            const lngDiff = (lng - refLng) * 111000 * Math.cos(refLat * Math.PI / 180);
            
            // Map to grid: bottom-left anchor as origin (0,0), scale to fit 20m area
            // x: longitude difference (east-west)
            // y: latitude difference (north-south)
            return { x: lngDiff, y: latDiff };
        }
        
        // Load anchors from database
        function loadAnchorsFromDatabase() {
            fetch('/api/anchors')
                .then(response => response.json())
                .then(data => {
                    console.log('‚úÖ Loaded anchors from DB:', data);
                    
                    if (data.length === 0) {
                        console.warn('‚ö†Ô∏è No anchors in database');
                        anchors = [];
                        draw();
                        return;
                    }
                    
                    // ‚úÖ Filter anchors by zone if in detail mode
                    let filteredData = data;
                    if (currentZoneId) {
                        filteredData = data.filter(anchor => anchor.zoneId == currentZoneId);
                        console.log(`üîç Filtered to ${filteredData.length} anchors for zone ${currentZoneId}`);
                        
                        if (filteredData.length === 0) {
                            console.warn('‚ö†Ô∏è No anchors in this zone');
                            anchors = [];
                            draw();
                            return;
                        }
                    }
                    
                    // Use first anchor as reference point (origin)
                    referencePoint = {
                        lat: filteredData[0].latitude,
                        lng: filteredData[0].longitude
                    };
                    
                    // Convert all anchors to relative coordinates
                    const converted = filteredData.map(anchor => {
                        const pos = latLngToXY(anchor.latitude, anchor.longitude, referencePoint.lat, referencePoint.lng);
                        return {
                            id: anchor.anchorId,
                            name: anchor.name,
                            rawX: pos.x,
                            rawY: pos.y,
                            lat: anchor.latitude,
                            lng: anchor.longitude,
                            zoneId: anchor.zoneId,
                            status: 'online'
                        };
                    });
                    
                    // Find bounds
                    const xCoords = converted.map(a => a.rawX);
                    const yCoords = converted.map(a => a.rawY);
                    const minX = Math.min(...xCoords);
                    const maxX = Math.max(...xCoords);
                    const minY = Math.min(...yCoords);
                    const maxY = Math.max(...yCoords);
                    
                    const rangeX = maxX - minX || 1;
                    const rangeY = maxY - minY || 1;
                    const maxRange = Math.max(rangeX, rangeY);
                    
                    // Scale to fit in 18m x 18m (leave 1m margin on each side)
                    const scaleFactor = maxRange > 0 ? 18 / maxRange : 1;
                    
                    anchors = converted.map(anchor => ({
                        id: anchor.id,
                        name: anchor.name,
                        x: 1 + (anchor.rawX - minX) * scaleFactor,  // 1m margin
                        y: 1 + (anchor.rawY - minY) * scaleFactor,  // 1m margin
                        zoneId: anchor.zoneId,
                        status: anchor.status
                    }));
                    
                    console.log('‚úÖ Converted anchors to 2D:', anchors);
                    console.log('üìä Bounds:', { minX, maxX, minY, maxY, scaleFactor });
                    draw(); // Redraw canvas with new anchors
                })
                .catch(error => {
                    console.error('‚ùå Error loading anchors:', error);
                    anchors = [];
                    draw();
                });
        }

        // Safe zones data
        let safeZones = [];
        
        // Load safe zones from API
        function loadSafeZones() {
            fetch('/api/safe-zones')
                .then(response => response.json())
                .then(zones => {
                    safeZones = zones.filter(z => z.active).map(zone => ({
                        id: zone.id,
                        name: zone.zoneName,
                        coordinates: zone.polygonCoordinates,
                        color: zone.color || '#4CAF50'
                    }));
                    console.log('‚úÖ Loaded', safeZones.length, 'safe zones');
                    draw();
                })
                .catch(error => {
                    console.error('‚ùå Error loading safe zones:', error);
                    safeZones = [];
                });
        }
        
        // Check if point is inside polygon (Ray casting algorithm)
        function isPointInPolygon(x, y, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                
                const intersect = ((yi > y) !== (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }
        
        // Check if worker is in any safe zone
        function isWorkerInSafeZone(tag) {
            // DEFAULT: ALL workers are INSIDE safe zone (GREEN)
            // Only show RED if explicitly outside
            
            // Simple approach: If worker is very close to canvas edges, show RED
            const margin = 1; // 1 meter margin from edge
            if (tag.x < margin || tag.x > (areaSize - margin) || 
                tag.y < margin || tag.y > (areaSize - margin)) {
                return false; // Near boundary = outside
            }
            
            // Otherwise, always GREEN (inside safe zone)
            return true;
        }

        // Sample data - Tags (moving positions)
        let tags = []; // ‚úÖ B·ªè d·ªØ li·ªáu demo, ch·ªâ d√πng d·ªØ li·ªáu th·ª±c t·ª´ UWB

        // Calculate distance between two points
        function calculateDistance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        // Find nearest anchor for each tag
        function findNearestAnchor(tag) {
            let minDistance = Infinity;
            let nearestAnchor = null;

            anchors.forEach(anchor => {
                const dist = calculateDistance(tag.x, tag.y, anchor.x, anchor.y);
                if (dist < minDistance) {
                    minDistance = dist;
                    nearestAnchor = anchor;
                }
            });

            return { anchor: nearestAnchor, distance: minDistance };
        }

        // Draw grid
        function drawGrid() {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            // Vertical lines
            for (let i = 0; i <= areaSize; i++) {
                ctx.beginPath();
                ctx.moveTo(i * scale, 0);
                ctx.lineTo(i * scale, areaSize * scale);
                ctx.stroke();
            }

            // Horizontal lines
            for (let i = 0; i <= areaSize; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * scale);
                ctx.lineTo(areaSize * scale, i * scale);
                ctx.stroke();
            }

            // Draw labels
            ctx.fillStyle = '#999';
            ctx.font = '10px Arial';
            for (let i = 0; i <= areaSize; i += 5) {
                ctx.fillText(i + 'm', i * scale - 8, areaSize * scale + 15);
                ctx.fillText(i + 'm', -20, areaSize * scale - i * scale + 5);
            }
        }

        // Draw anchor
        function drawAnchor(anchor) {
            const x = anchor.x * scale;
            const y = (areaSize - anchor.y) * scale;

            // Draw circle
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, 2 * Math.PI);
            ctx.fillStyle = anchor.status === 'online' ? '#2196F3' : '#999';
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw label
            ctx.fillStyle = '#333';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(anchor.id, x, y - 15);
        }

        // Draw tag v·ªõi m√†u theo status (online=xanh, offline=x√°m)
        function drawTag(tag) {
            const x = tag.x * scale;
            const y = (areaSize - tag.y) * scale;
            
            // üé® M√†u s·∫Øc theo status
            let markerColor;
            if (tag.status === 'offline') {
                markerColor = '#9E9E9E'; // ‚ö™ X√ÅM khi offline
            } else if (tag.status === 'warning') {
                markerColor = '#FF9800'; // üü† CAM khi c·∫£nh b√°o
            } else {
                markerColor = '#f44336'; // üî¥ ƒê·ªé khi online (d·ªÖ nh√¨n h∆°n xanh)
            }

            // Draw circle with glow effect for online tags
            if (tag.status === 'online') {
                ctx.beginPath();
                ctx.arc(x, y, 14, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(244, 67, 54, 0.3)';
                ctx.fill();
            }
            
            // Draw main circle
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, 2 * Math.PI);
            ctx.fillStyle = markerColor;
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw label with name
            ctx.fillStyle = '#333';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(tag.id, x, y + 25);
            
            // Draw battery indicator if available
            if (tag.battery !== undefined) {
                const batteryText = `${Math.round(tag.battery)}%`;
                ctx.font = '10px Arial';
                ctx.fillStyle = tag.battery < 20 ? '#f44336' : '#666';
                ctx.fillText(batteryText, x, y + 38);
            }
        }

        // Draw distance lines from tag to ALL anchors with UWB data
        function drawTagDistanceLines(tag) {
            if (!tag.uwb) return;
            
            const x1 = tag.x * scale;
            const y1 = (areaSize - tag.y) * scale;
            
            // Draw line to each anchor
            anchors.forEach(anchor => {
                const anchorKey = anchor.id; // A0, A1, A2
                const distance = tag.uwb[anchorKey];
                
                if (distance && distance > 0) {
                    const x2 = anchor.x * scale;
                    const y2 = (areaSize - anchor.y) * scale;
                    
                    // Draw dashed line
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.strokeStyle = 'rgba(255, 152, 0, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Draw distance label at midpoint
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(midX - 18, midY - 8, 36, 16);
                    ctx.strokeStyle = '#FF9800';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(midX - 18, midY - 8, 36, 16);
                    
                    ctx.fillStyle = '#333';
                    ctx.font = 'bold 9px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(distance.toFixed(2) + 'm', midX, midY + 3);
                }
            });
        }

        // Draw distance line (legacy - for nearest anchor only)
        function drawDistanceLine(tag, anchor, distance) {
            const x1 = tag.x * scale;
            const y1 = (areaSize - tag.y) * scale;
            const x2 = anchor.x * scale;
            const y2 = (areaSize - anchor.y) * scale;

            // Draw line
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = 'rgba(76, 175, 80, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw distance label
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            ctx.fillStyle = '#fff';
            ctx.fillRect(midX - 25, midY - 10, 50, 20);
            ctx.strokeStyle = '#4CAF50';
            ctx.strokeRect(midX - 25, midY - 10, 50, 20);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(distance.toFixed(2) + 'm', midX, midY + 4);
        }

        // Update tag positions (simulate movement)
        function updateTagPositions() {
            if (!isAnimating) return;

            tags.forEach(tag => {
                // Update position
                tag.x += tag.vx;
                tag.y += tag.vy;

                // Bounce off walls
                if (tag.x <= 1 || tag.x >= areaSize - 1) {
                    tag.vx *= -1;
                }
                if (tag.y <= 1 || tag.y >= areaSize - 1) {
                    tag.vy *= -1;
                }

                // Keep within bounds
                tag.x = Math.max(1, Math.min(areaSize - 1, tag.x));
                tag.y = Math.max(1, Math.min(areaSize - 1, tag.y));
            });
        }

        // Draw safe zone polygon
        function drawSafeZone(zone) {
            if (!zone.coordinates || zone.coordinates.length < 3) return;
            
            ctx.beginPath();
            zone.coordinates.forEach((coord, index) => {
                // Convert to canvas coordinates - simplified for now
                // TODO: Implement proper lat/lng to canvas conversion
                const x = coord.lng * scale; // Simplified
                const y = (areaSize - coord.lat) * scale; // Simplified
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.closePath();
            
            // Fill with semi-transparent green
            ctx.fillStyle = 'rgba(76, 175, 80, 0.15)';
            ctx.fill();
            
            // Stroke with green border
            ctx.strokeStyle = zone.color || '#4CAF50';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw zone name
            if (zone.coordinates.length > 0) {
                const centerX = zone.coordinates.reduce((sum, c) => sum + c.lng, 0) / zone.coordinates.length * scale;
                const centerY = (areaSize - zone.coordinates.reduce((sum, c) => sum + c.lat, 0) / zone.coordinates.length) * scale;
                
                ctx.fillStyle = '#2E7D32';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(zone.name, centerX, centerY);
            }
        }

        // Main draw function
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Save context
            ctx.save();
            
            // Add padding
            ctx.translate(40, 40);

            // Draw grid
            drawGrid();
            
            // Draw safe zones FIRST (as background)
            safeZones.forEach(zone => drawSafeZone(zone));

            // üéØ Draw UWB distance lines from tags to anchors (with real distances)
            tags.forEach(tag => {
                if (tag.uwb && tag.status === 'online') {
                    drawTagDistanceLines(tag);
                } else {
                    // Fallback: Draw line to nearest anchor only
                    const { anchor, distance } = findNearestAnchor(tag);
                    if (anchor) {
                        drawDistanceLine(tag, anchor, distance);
                    }
                }
            });

            // Draw anchors
            anchors.forEach(anchor => drawAnchor(anchor));

            // Draw tags
            tags.forEach(tag => drawTag(tag));

            // Restore context
            ctx.restore();

            // Update lists
            updateLists();
        }

        // Update anchor and tag lists
        function updateLists() {
            // Update anchor list
            const anchorList = document.getElementById('anchorList');
            anchorList.innerHTML = anchors.map(anchor => `
                <li class="device-item">
                    <span class="status-indicator ${anchor.status}"></span>
                    <strong>${anchor.id}</strong> - ${anchor.name}
                    <div class="distance-info">V·ªã tr√≠: (${anchor.x.toFixed(1)}m, ${anchor.y.toFixed(1)}m)</div>
                </li>
            `).join('');

            // Update tag list with UWB info
            const tagList = document.getElementById('tagList');
            tagList.innerHTML = tags.map(tag => {
                const { anchor, distance } = findNearestAnchor(tag);
                const uwbInfo = tag.uwb ? 
                    `A0: ${tag.uwb.A0?.toFixed(2) || '-'}m, A1: ${tag.uwb.A1?.toFixed(2) || '-'}m, A2: ${tag.uwb.A2?.toFixed(2) || '-'}m` : 
                    'No UWB data';
                const statusClass = tag.status === 'offline' ? 'offline' : 'online';
                const statusIcon = tag.status === 'offline' ? '‚ö™' : 'üî¥';
                const batteryInfo = tag.battery !== undefined ? `üîã ${Math.round(tag.battery)}%` : '';
                return `
                    <li class="device-item tag" style="border-left-color: ${tag.status === 'offline' ? '#9E9E9E' : '#f44336'}">
                        <span class="status-indicator ${statusClass}"></span>
                        ${statusIcon} <strong>${tag.id}</strong> - ${tag.name} ${batteryInfo}
                        <div class="distance-info">
                            üìç V·ªã tr√≠: (${tag.x.toFixed(2)}m, ${tag.y.toFixed(2)}m)<br>
                            üìè UWB: ${uwbInfo}<br>
                            üéØ G·∫ßn nh·∫•t: ${anchor ? anchor.id : 'N/A'} (${distance.toFixed(2)}m)
                        </div>
                    </li>
                `;
            }).join('');

            // Update statistics
            document.getElementById('totalAnchors').textContent = anchors.length;
            document.getElementById('totalTags').textContent = tags.length;
            document.getElementById('activeTags').textContent = tags.filter(t => t.status === 'online').length;
            
            const onlineTags = tags.filter(t => t.status === 'online');
            const avgDist = onlineTags.length > 0 ? onlineTags.reduce((sum, tag) => {
                const { distance } = findNearestAnchor(tag);
                return sum + distance;
            }, 0) / onlineTags.length : 0;
            document.getElementById('avgDistance').textContent = avgDist.toFixed(2);
        }

        // Animation loop
        function animate() {
            updateTagPositions();
            draw();
            requestAnimationFrame(animate);
        }

        // Scale slider
        document.getElementById('scaleSlider').addEventListener('input', (e) => {
            scale = parseInt(e.target.value);
            document.getElementById('scaleValue').textContent = scale;
            draw();
        });

        // Reset view
        function resetView() {
            scale = 20;
            document.getElementById('scaleSlider').value = 20;
            document.getElementById('scaleValue').textContent = 20;
            
            // ‚úÖ Kh√¥ng reset tags n·ªØa, gi·ªØ nguy√™n tags t·ª´ UWB
            // Tags s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t t·ª± ƒë·ªông t·ª´ WebSocket
            
            draw();
        }

        // Toggle animation
        function toggleAnimation() {
            isAnimating = !isAnimating;
            document.getElementById('animationBtn').textContent = isAnimating ? '‚è∏ D·ª´ng' : '‚ñ∂Ô∏è Ch·∫°y';
        }

        // Logout function
        function logout() {
            sessionStorage.removeItem('isLoggedIn');
            sessionStorage.removeItem('username');
            window.location.href = 'login.html';
        }

        // ==========================================
        // WEBSOCKET REALTIME UPDATES
        // ==========================================
        
        let stompClient = null;
        let helmetPositions = {}; // Store helmet positions by MAC
        
        /**
         * Thu·∫≠t to√°n Trilateration c·∫£i ti·∫øn - T√≠nh t·ªça ƒë·ªô 2D t·ª´ 3 anchor
         * S·ª≠ d·ª•ng ph∆∞∆°ng ph√°p least squares ƒë·ªÉ tƒÉng ƒë·ªô ch√≠nh x√°c
         */
        function trilateration(a1, a2, a3, d1, d2, d3) {
            // a1, a2, a3: {x, y} t·ªça ƒë·ªô anchor
            // d1, d2, d3: kho·∫£ng c√°ch t·ª´ tag ƒë·∫øn anchor t∆∞∆°ng ·ª©ng
            
            const x1 = a1.x, y1 = a1.y;
            const x2 = a2.x, y2 = a2.y;
            const x3 = a3.x, y3 = a3.y;
            
            // Ph∆∞∆°ng tr√¨nh trilateration chu·∫©n
            // (x - x1)¬≤ + (y - y1)¬≤ = d1¬≤
            // (x - x2)¬≤ + (y - y2)¬≤ = d2¬≤
            // (x - x3)¬≤ + (y - y3)¬≤ = d3¬≤
            
            // Chuy·ªÉn v·ªÅ d·∫°ng tuy·∫øn t√≠nh b·∫±ng c√°ch tr·ª´ ph∆∞∆°ng tr√¨nh
            const A = 2 * (x2 - x1);
            const B = 2 * (y2 - y1);
            const C = d1*d1 - d2*d2 - x1*x1 + x2*x2 - y1*y1 + y2*y2;
            
            const D = 2 * (x3 - x1);
            const E = 2 * (y3 - y1);
            const F = d1*d1 - d3*d3 - x1*x1 + x3*x3 - y1*y1 + y3*y3;
            
            // Gi·∫£i h·ªá ph∆∞∆°ng tr√¨nh: Ax + By = C v√† Dx + Ey = F
            const denom = A * E - B * D;
            
            if (Math.abs(denom) < 0.0001) {
                console.warn('‚ö†Ô∏è Trilateration: Anchors are collinear');
                return null;
            }
            
            const x = (C * E - F * B) / denom;
            const y = (A * F - D * C) / denom;
            
            // Ki·ªÉm tra k·∫øt qu·∫£ h·ª£p l·ªá
            if (isNaN(x) || isNaN(y) || !isFinite(x) || !isFinite(y)) {
                console.warn('‚ö†Ô∏è Trilateration failed, invalid result:', {x, y});
                return null;
            }
            
            console.log(`üìç Trilateration result: (${x.toFixed(2)}, ${y.toFixed(2)})`);
            
            // Gi·ªõi h·∫°n trong khu v·ª±c 0-20m
            const clampedX = Math.max(0, Math.min(areaSize, x));
            const clampedY = Math.max(0, Math.min(areaSize, y));
            
            return { x: clampedX, y: clampedY };
        }
        
        /**
         * üéØ C·ªê ƒê·ªäNH V·ªä TR√ç ANCHOR CHO UWB POSITIONING
         * C√°c anchor A0, A1, A2 ƒë∆∞·ª£c ƒë·∫∑t c·ªë ƒë·ªãnh trong kh√¥ng gian 20m x 20m
         * ƒê·ªìng b·ªô v·ªõi d·ªØ li·ªáu UWB t·ª´ ESP32: A0, A1, A2
         * 
         * Layout th·ª±c t·∫ø (nh√¨n t·ª´ m√†n h√¨nh):
         *       A1 (1, 11) ‚Üê ph√≠a tr√™n tr√°i
         *       |
         *       |
         *  A0 (1, 2) ‚Üê----‚Üí A2 (18, 1) ph√≠a d∆∞·ªõi
         */
        const UWB_ANCHORS = {
            A0: { x: 1, y: 2 },    // Anchor A0 - g√≥c d∆∞·ªõi tr√°i
            A1: { x: 1, y: 11 },   // Anchor A1 - ph√≠a tr√™n tr√°i  
            A2: { x: 18, y: 1 }    // Anchor A2 - g√≥c d∆∞·ªõi ph·∫£i
        };
        
        /**
         * T√≠nh t·ªça ƒë·ªô tag t·ª´ UWB data s·ª≠ d·ª•ng Trilateration c·∫£i ti·∫øn
         */
        function calculatePositionFromUWB(uwb, mac) {
            // S·ª≠ d·ª•ng anchor positions c·ªë ƒë·ªãnh cho UWB
            const a0 = UWB_ANCHORS.A0;
            const a1 = UWB_ANCHORS.A1;
            const a2 = UWB_ANCHORS.A2;
            
            // Kho·∫£ng c√°ch t·ª´ UWB (meters) - ƒë·∫£m b·∫£o gi√° tr·ªã d∆∞∆°ng
            const d0 = uwb.A0 !== undefined && uwb.A0 > 0 ? uwb.A0 : -1;
            const d1 = uwb.A1 !== undefined && uwb.A1 > 0 ? uwb.A1 : -1;
            const d2 = uwb.A2 !== undefined && uwb.A2 > 0 ? uwb.A2 : -1;
            
            // B·ªè qua n·∫øu kho·∫£ng c√°ch kh√¥ng h·ª£p l·ªá
            if (d0 <= 0 || d1 <= 0 || d2 <= 0) {
                console.log('‚ö†Ô∏è Invalid UWB distances:', {d0, d1, d2});
                return null;
            }
            
            console.log(`üìè UWB distances for ${mac}:`, {
                A0: d0.toFixed(2) + 'm',
                A1: d1.toFixed(2) + 'm',
                A2: d2.toFixed(2) + 'm'
            });
            
            // T√≠nh t·ªça ƒë·ªô b·∫±ng trilateration c·∫£i ti·∫øn
            const pos = trilateration(a0, a1, a2, d0, d1, d2);
            
            if (pos) {
                console.log(`‚úÖ Calculated position for ${mac}:`, 
                    `(${pos.x.toFixed(2)}m, ${pos.y.toFixed(2)}m)`);
            }
            
            return pos;
        }
        
        /**
         * X·ª≠ l√Ω helmet data t·ª´ WebSocket
         */
        function handleHelmetData(data) {
            console.log('üì° Received helmet data:', data.mac);
            
            // Ki·ªÉm tra c√≥ UWB data kh√¥ng
            if (!data.uwb || data.uwb.ready !== 1) {
                console.log('‚ö†Ô∏è UWB not ready for', data.mac);
                return;
            }
            
            // T√≠nh t·ªça ƒë·ªô t·ª´ UWB
            const position = calculatePositionFromUWB(data.uwb, data.mac);
            
            if (!position) {
                return;
            }
            
            // C·∫≠p nh·∫≠t ho·∫∑c t·∫°o tag m·ªõi
            let tag = tags.find(t => t.helmet === data.mac);
            
            if (tag) {
                // C·∫≠p nh·∫≠t v·ªã tr√≠
                tag.x = position.x;
                tag.y = position.y;
                tag.status = 'online';
                console.log(`üîÑ Updated tag ${tag.id} position`);
            } else {
                // T·∫°o tag m·ªõi
                const newTag = {
                    id: 'T' + (tags.length + 1),
                    name: data.employeeName || data.mac,
                    x: position.x,
                    y: position.y,
                    vx: 0,
                    vy: 0,
                    status: 'online',
                    helmet: data.mac
                };
                tags.push(newTag);
                console.log(`‚ûï Created new tag ${newTag.id} for ${data.mac}`);
            }
            
            // L∆∞u v√†o cache
            helmetPositions[data.mac] = {
                position: position,
                timestamp: Date.now(),
                battery: data.battery,
                uwb: data.uwb
            };
        }
        
        /**
         * K·∫øt n·ªëi WebSocket
         */
        function connectWebSocket() {
            console.log('üîå Connecting to WebSocket...');
            
            const socket = new SockJS('/ws');
            stompClient = Stomp.over(socket);
            
            // Disable debug logs
            stompClient.debug = null;
            
            stompClient.connect({}, function(frame) {
                console.log('‚úÖ WebSocket connected:', frame);
                
                // üéØ Subscribe to REALTIME POSITION updates (with UWB data)
                stompClient.subscribe('/topic/helmet/position', function(message) {
                    try {
                        const data = JSON.parse(message.body);
                        handleRealtimePosition(data);
                    } catch (e) {
                        console.error('‚ùå Error parsing position data:', e);
                    }
                });
                
                // Also subscribe to legacy helmet data (for backward compatibility)
                stompClient.subscribe('/topic/helmet/data', function(message) {
                    try {
                        const data = JSON.parse(message.body);
                        // Only use if no UWB data in position topic
                        if (!data.uwb) {
                            handleHelmetData(data);
                        }
                    } catch (e) {
                        console.error('‚ùå Error parsing helmet data:', e);
                    }
                });
                
            }, function(error) {
                console.error('‚ùå WebSocket error:', error);
                
                // Reconnect sau 5s
                setTimeout(() => {
                    console.log('üîÑ Reconnecting WebSocket...');
                    connectWebSocket();
                }, 5000);
            });
        }
        
        /**
         * üéØ X·ª≠ l√Ω realtime position v·ªõi UWB data
         */
        function handleRealtimePosition(data) {
            console.log('üìç Realtime position received:', data);
            
            // Ki·ªÉm tra status offline (tag chuy·ªÉn m√†u x√°m)
            if (data.status === 'offline') {
                let tag = tags.find(t => t.helmet === data.mac);
                if (tag) {
                    tag.status = 'offline';
                    console.log(`‚ö™ Tag ${tag.id} is now OFFLINE (grey)`);
                }
                draw();
                return;
            }
            
            // Ki·ªÉm tra c√≥ UWB data kh√¥ng
            // Support c·∫£ 2 format: {uwb: {...}, uwbReady: true} ho·∫∑c {uwb: {ready: 1, ...}}
            const uwbData = data.uwb;
            const isReady = data.uwbReady === true || (uwbData && uwbData.ready === 1);
            
            if (!uwbData) {
                console.log('‚ö†Ô∏è No UWB data for', data.mac);
                return;
            }
            
            if (!isReady) {
                console.log('‚ö†Ô∏è UWB not ready for', data.mac, 'ready=', uwbData?.ready);
                return;
            }
            
            console.log('üì° UWB Data:', uwbData);
            
            // T√≠nh t·ªça ƒë·ªô t·ª´ UWB
            const position = calculatePositionFromUWB(uwbData, data.mac);
            
            if (!position) {
                console.log('‚ö†Ô∏è Could not calculate position');
                return;
            }
            
            // C·∫≠p nh·∫≠t ho·∫∑c t·∫°o tag m·ªõi
            let tag = tags.find(t => t.helmet === data.mac);
            
            if (tag) {
                // Smooth movement - interpolate to new position
                const smoothFactor = 0.3; // 0 = no change, 1 = instant jump
                tag.x = tag.x + (position.x - tag.x) * smoothFactor;
                tag.y = tag.y + (position.y - tag.y) * smoothFactor;
                tag.status = 'online';
                tag.battery = data.battery;
                tag.uwb = uwbData;
                console.log(`üîÑ Updated tag ${tag.id} to (${tag.x.toFixed(2)}, ${tag.y.toFixed(2)})`);
            } else {
                // T·∫°o tag m·ªõi
                const newTag = {
                    id: 'TAG' + (tags.length + 1),
                    name: data.employeeName || data.mac.slice(-4),
                    x: position.x,
                    y: position.y,
                    vx: 0,
                    vy: 0,
                    status: 'online',
                    helmet: data.mac,
                    battery: data.battery,
                    uwb: uwbData
                };
                tags.push(newTag);
                console.log(`‚ûï Created new tag ${newTag.id} for ${data.mac} at (${position.x.toFixed(2)}, ${position.y.toFixed(2)})`);
            }
            
            // L∆∞u v√†o cache (for display purposes only)
            helmetPositions[data.mac] = {
                position: position,
                timestamp: Date.now(),
                battery: data.battery,
                uwb: uwbData
            };
            
            // Trigger redraw
            draw();
        }
        
        // ==========================================
        // END WEBSOCKET
        // ==========================================
        
        // Auto-refresh anchors every 10 seconds
        function startAnchorSync() {
            console.log('üîÑ Starting anchor sync...');
            loadAnchorsFromDatabase(); // Initial load
            setInterval(() => {
                console.log('üîÑ Refreshing anchors...');
                loadAnchorsFromDatabase();
            }, 10000); // Refresh every 10s
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üìç Page loaded, initializing...');
            
            // Check auth if function exists
            if (typeof checkAuth === 'function') {
                checkAuth();
            }
            
            // Set canvas size
            canvas.width = areaSize * scale + 80;
            canvas.height = areaSize * scale + 80;
            
            loadSafeZones(); // Load safe zones for color detection
            startAnchorSync(); // Load anchors from DB
            connectWebSocket(); // Connect WebSocket for realtime UWB data
            animate();
            
            // Start updating demo tag distances
            updateDemoTagDistances();
        });

        // ==========================================
        // DEMO TAG DISTANCE LINES
        // ==========================================
        function updateDemoTagDistances() {
            const canvasWrapper = document.getElementById('canvasWrapper');
            const canvas = document.getElementById('canvas2d');
            
            if (!canvasWrapper || !canvas) {
                console.error('‚ùå Canvas wrapper or canvas not found');
                return;
            }
            
            console.log('‚úÖ Starting demo tag distance updates');
            
            // Create distance lines container if not exists
            let linesContainer = document.getElementById('demoDistanceLines');
            if (!linesContainer) {
                linesContainer = document.createElement('div');
                linesContainer.id = 'demoDistanceLines';
                linesContainer.style.position = 'absolute';
                linesContainer.style.top = '0';
                linesContainer.style.left = '0';
                linesContainer.style.width = '100%';
                linesContainer.style.height = '100%';
                linesContainer.style.pointerEvents = 'none';
                linesContainer.style.zIndex = '15';
                canvasWrapper.appendChild(linesContainer);
                console.log('‚úÖ Created distance lines container');
            }
            
            // Update every 100ms for smooth animation
            setInterval(() => {
                if (!isAnimating) {
                    linesContainer.innerHTML = '';
                    return;
                }
                
                // Get demo tag positions
                const tag1 = document.querySelector('.demo-tag-1');
                const tag2 = document.querySelector('.demo-tag-2');
                const tag3 = document.querySelector('.demo-tag-3');
                
                if (!tag1 || !tag2 || !tag3) {
                    console.warn('‚ö†Ô∏è Demo tags not found');
                    return;
                }
                
                // Get anchor positions from canvas (A1, A2, A3)
                // A1 (2, 20), A2 (5, 2), A3 (20, 17)
                const anchorPositions = [
                    { id: 'A1', x: 2, y: 20 },
                    { id: 'A2', x: 5, y: 2 },
                    { id: 'A3', x: 20, y: 17 }
                ];
                
                const demoTags = [
                    { element: tag1, name: 'TAG1' },
                    { element: tag2, name: 'TAG2' },
                    { element: tag3, name: 'TAG3' }
                ];
                
                // Clear previous lines
                linesContainer.innerHTML = '';
                
                // Draw lines from each tag to nearest anchor
                demoTags.forEach(tag => {
                    const wrapperRect = canvasWrapper.getBoundingClientRect();
                    const tagRect = tag.element.getBoundingClientRect();
                    
                    // Tag position relative to wrapper
                    const tagX = tagRect.left - wrapperRect.left + tagRect.width / 2;
                    const tagY = tagRect.top - wrapperRect.top + tagRect.height / 2;
                    
                    // Convert tag pixel position to meters
                    const tagMeterX = (tagX - 40) / scale;
                    const tagMeterY = (canvas.height - tagY - 40) / scale;
                    
                    // Find nearest anchor
                    let nearestAnchor = null;
                    let minDistance = Infinity;
                    
                    anchorPositions.forEach(anchor => {
                        const dx = tagMeterX - anchor.x;
                        const dy = tagMeterY - anchor.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestAnchor = anchor;
                        }
                    });
                    
                    if (!nearestAnchor) return;
                    
                    // Convert anchor meter position to pixels
                    const anchorX = nearestAnchor.x * scale + 40;
                    const anchorY = canvas.height - (nearestAnchor.y * scale + 40);
                    
                    // Draw line
                    const dx = anchorX - tagX;
                    const dy = anchorY - tagY;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    const line = document.createElement('div');
                    line.className = 'distance-line';
                    line.style.left = tagX + 'px';
                    line.style.top = tagY + 'px';
                    line.style.width = length + 'px';
                    line.style.transform = `rotate(${angle}deg)`;
                    linesContainer.appendChild(line);
                    
                    // Draw distance label
                    const label = document.createElement('div');
                    label.className = 'distance-label';
                    label.textContent = minDistance.toFixed(1) + 'm ‚Üí ' + nearestAnchor.id;
                    label.style.left = (tagX + dx / 2 - 35) + 'px';
                    label.style.top = (tagY + dy / 2 - 10) + 'px';
                    linesContainer.appendChild(label);
                });
                
            }, 100);
        }
    </script>
</body>
</html>
